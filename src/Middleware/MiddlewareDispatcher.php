<?php

namespace Hazaar\Middleware;

use Hazaar\Application\Request;
use Hazaar\Controller\Response;
use Hazaar\Middleware\Interface\Middleware;

/**
 * Class MiddlewareDispatcher.
 *
 * Responsible for managing and dispatching middleware components within the application.
 * Handles the execution flow of middleware stacks, allowing for request and response
 * manipulation at various stages of the application's lifecycle.
 */
class MiddlewareDispatcher
{
    /**
     * Stores aliases for middleware classes.
     *
     * @var array<string, string>
     */
    public static array $aliases = [];

    /**
     * Stack of middleware components to be executed in order.
     *
     * @var array<Middleware>
     */
    private array $middlewareStack = [];

    /**
     * MiddlewareDispatcher constructor.
     *
     * Initializes the middleware dispatcher with an empty stack.
     *
     * Optionally accepts a configuration array to load global middleware and aliases.
     * This allows for dynamic configuration of middleware components
     * and their aliases, enhancing the flexibility of the middleware system.
     *
     * @param array<string, string> $middlwareAliases an associative array of middleware aliases
     *                                                where keys are alias names and values are fully qualified class names of middleware.
     *                                                This allows for easy reference to middleware classes without needing to specify their full paths.
     *
     * @throws \InvalidArgumentException if a class does not exist or does not implement Middleware interface
     */
    public function __construct(array $middlwareAliases = [])
    {
        self::$aliases = array_merge(self::$aliases, $middlwareAliases);
    }

    /**
     * Adds a middleware instance to the middleware stack.
     *
     * @param Middleware $middleware the middleware to add to the stack
     */
    public function add(Middleware|string $middleware): void
    {
        if (is_string($middleware)) {
            if (array_key_exists($middleware, self::$aliases)) {
                $middleware = self::$aliases[$middleware];
            }
            if (!class_exists($middleware)) {
                throw new \InvalidArgumentException("Class {$middleware} does not exist.");
            }
            if (!is_subclass_of($middleware, Middleware::class)) {
                throw new \InvalidArgumentException("Class {$middleware} does not implement Middleware interface.");
            }
            $middleware = new $middleware();
        }
        $this->middlewareStack[] = $middleware;
    }

    /**
     * Adds an array of global middleware classes to the dispatcher.
     *
     * Each class in the provided array is validated to ensure it exists and implements the Middleware interface.
     * If a class does not exist or does not implement the required interface, an InvalidArgumentException is thrown.
     * Valid middleware classes are instantiated and added to the dispatcher.
     *
     * @param array<string> $middlewareClasses array of middleware class names to add
     *
     * @throws \InvalidArgumentException if a class does not exist or does not implement Middleware interface
     */
    public function addFromArray(array $middlewareClasses): void
    {
        foreach ($middlewareClasses as $middlewareClass) {
            $this->add($middlewareClass);
        }
    }

    /**
     * Handles the incoming HTTP request by passing it through the middleware stack.
     *
     * This method reverses the middleware stack and wraps each middleware around the next,
     * creating a chain of responsibility. The final handler is called after all middleware
     * have been processed.
     *
     * @param Request  $request      the incoming HTTP request to handle
     * @param callable $finalHandler the final handler to be called after all middleware
     *
     * @return Response the HTTP response generated by the middleware stack or final handler
     */
    public function handle(Request $request, callable $finalHandler): Response
    {
        $stack = array_reverse($this->middlewareStack);
        $next = $finalHandler;
        foreach ($stack as $middleware) {
            $next = function (Request $request) use ($middleware, $next) {
                return $middleware->handle($request, $next);
            };
        }

        // Call the final next function which should be the controller or last middleware
        return $next($request);
    }
}
