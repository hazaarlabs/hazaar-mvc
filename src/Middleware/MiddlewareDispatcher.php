<?php

namespace Hazaar\Middleware;

use Hazaar\Application\Request;
use Hazaar\Controller\Response;
use Hazaar\Middleware\Interface\Middleware;

/**
 * Class MiddlewareDispatcher.
 *
 * Responsible for managing and dispatching middleware components within the application.
 * Handles the execution flow of middleware stacks, allowing for request and response
 * manipulation at various stages of the application's lifecycle.
 */
class MiddlewareDispatcher
{
    /**
     * Stack of middleware components to be executed in order.
     *
     * @var array<Middleware>
     */
    private array $middlewareStack = [];

    /**
     * Adds a middleware instance to the middleware stack.
     *
     * @param Middleware $middleware the middleware to add to the stack
     */
    public function add(Middleware $middleware): void
    {
        $this->middlewareStack[] = $middleware;
    }

    /**
     * Loads and registers middleware classes from the specified directory.
     *
     * Scans the given directory for PHP files, constructs the fully qualified class name
     * for each file, and checks if the class exists and implements the Middleware interface.
     * If valid, the middleware is instantiated and added to the dispatcher.
     *
     * @param string $directory the directory path containing middleware PHP files
     *
     * @throws \InvalidArgumentException if the directory does not exist or if a class does not implement the Middleware interface
     */
    public function loadMiddleware(string $directory): void
    {
        if (!is_dir($directory)) {
            throw new \InvalidArgumentException("Directory {$directory} does not exist.");
        }

        foreach (glob($directory.'/*.php') as $file) {
            $middlewareClass = 'App\Middleware\\'.basename($file, '.php');
            if (!class_exists($middlewareClass)) {
                continue;
            }
            if (!is_subclass_of($middlewareClass, Middleware::class)) {
                throw new \InvalidArgumentException("Class {$middlewareClass} does not implement Middleware interface.");
            }
            $this->add(new $middlewareClass());
        }
    }

    /**
     * Handles the incoming HTTP request by passing it through the middleware stack.
     *
     * This method reverses the middleware stack and wraps each middleware around the next,
     * creating a chain of responsibility. The final handler is called after all middleware
     * have been processed.
     *
     * @param Request  $request      the incoming HTTP request to handle
     * @param callable $finalHandler the final handler to be called after all middleware
     *
     * @return Response the HTTP response generated by the middleware stack or final handler
     */
    public function handle(Request $request, callable $finalHandler): Response
    {
        $stack = array_reverse($this->middlewareStack);
        $next = $finalHandler;
        foreach ($stack as $middleware) {
            $next = function (Request $request) use ($middleware, $next) {
                return $middleware->handle($request, $next);
            };
        }

        // Call the final next function which should be the controller or last middleware
        return $next($request);
    }
}
