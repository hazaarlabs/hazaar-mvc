<?php

namespace Hazaar\Middleware;

use Hazaar\Application\Request;
use Hazaar\Controller\Response;
use Hazaar\Middleware\Interface\Middleware;

/**
 * Class MiddlewareDispatcher.
 *
 * Responsible for managing and dispatching middleware components within the application.
 * Handles the execution flow of middleware stacks, allowing for request and response
 * manipulation at various stages of the application's lifecycle.
 */
class MiddlewareDispatcher
{
    /**
     * Stack of middleware components to be executed in order.
     *
     * @var array<Middleware>
     */
    private array $middlewareStack = [];

    /**
     * Adds a middleware instance to the middleware stack.
     *
     * @param Middleware $middleware the middleware to add to the stack
     */
    public function add(Middleware $middleware): void
    {
        $this->middlewareStack[] = $middleware;
    }

    /**
     * Adds an array of global middleware classes to the dispatcher.
     *
     * Each class in the provided array is validated to ensure it exists and implements the Middleware interface.
     * If a class does not exist or does not implement the required interface, an InvalidArgumentException is thrown.
     * Valid middleware classes are instantiated and added to the dispatcher.
     *
     * @param array $middlewareClasses array of middleware class names to add
     *
     * @throws \InvalidArgumentException if a class does not exist or does not implement Middleware interface
     */
    public function addGlobalMiddleware(array $middlewareClasses): void
    {
        foreach ($middlewareClasses as $middlewareClass) {
            if (!class_exists($middlewareClass)) {
                throw new \InvalidArgumentException("Class {$middlewareClass} does not exist.");
            }
            if (!is_subclass_of($middlewareClass, Middleware::class)) {
                throw new \InvalidArgumentException("Class {$middlewareClass} does not implement Middleware interface.");
            }
            $this->add(new $middlewareClass());
        }
    }

    /**
     * Handles the incoming HTTP request by passing it through the middleware stack.
     *
     * This method reverses the middleware stack and wraps each middleware around the next,
     * creating a chain of responsibility. The final handler is called after all middleware
     * have been processed.
     *
     * @param Request  $request      the incoming HTTP request to handle
     * @param callable $finalHandler the final handler to be called after all middleware
     *
     * @return Response the HTTP response generated by the middleware stack or final handler
     */
    public function handle(Request $request, callable $finalHandler): Response
    {
        $stack = array_reverse($this->middlewareStack);
        $next = $finalHandler;
        foreach ($stack as $middleware) {
            $next = function (Request $request) use ($middleware, $next) {
                return $middleware->handle($request, $next);
            };
        }

        // Call the final next function which should be the controller or last middleware
        return $next($request);
    }
}
