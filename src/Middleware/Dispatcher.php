<?php

namespace Hazaar\Middleware;

use Hazaar\Application\Request;
use Hazaar\Controller\Response;
use Hazaar\Middleware\Interface\Middleware;

/**
 * Class MiddlewareDispatcher.
 *
 * Responsible for managing and dispatching middleware components within the application.
 * Handles the execution flow of middleware stacks, allowing for request and response
 * manipulation at various stages of the application's lifecycle.
 */
class Dispatcher
{
    /**
     * Stores aliases for middleware classes.
     *
     * @var array<string, string>
     */
    public static array $aliases = [];

    /**
     * Stack of middleware components to be executed in order.
     *
     * @var array<Handler>
     */
    private array $middlewareStack = [];

    /**
     * MiddlewareDispatcher constructor.
     *
     * Initializes the middleware dispatcher with an empty stack.
     *
     * Optionally accepts a configuration array to load global middleware and aliases.
     * This allows for dynamic configuration of middleware components
     * and their aliases, enhancing the flexibility of the middleware system.
     *
     * @param array<string, string> $middlwareAliases an associative array of middleware aliases
     *                                                where keys are alias names and values are fully qualified class names of middleware.
     *                                                This allows for easy reference to middleware classes without needing to specify their full paths.
     *
     * @throws \InvalidArgumentException if a class does not exist or does not implement Middleware interface
     */
    public function __construct(array $middlwareAliases = [])
    {
        self::$aliases = array_merge(self::$aliases, $middlwareAliases);
    }

    /**
     * Adds a middleware instance to the middleware stack.
     *
     * @param array<string>|string $middleware the middleware to add to the stack
     */
    public function add(array|Middleware|string $middleware, mixed ...$args): void
    {
        if ($middleware instanceof Middleware) {
            $middlewareHandler = new Handler(get_class($middleware), $args);
            $middlewareHandler->setInstance($middleware);
        } elseif (is_array($middleware)) {
            $name = array_shift($middleware);
            $middlewareHandler = new Handler($name, $middleware);
        } else {
            $middlewareHandler = new Handler($middleware);
        }
        $this->middlewareStack[] = $middlewareHandler;
    }

    /**
     * Adds an array of global middleware classes to the dispatcher.
     *
     * Each class in the provided array is validated to ensure it exists and implements the Middleware interface.
     * If a class does not exist or does not implement the required interface, an InvalidArgumentException is thrown.
     * Valid middleware classes are instantiated and added to the dispatcher.
     *
     * @param array<string> $middlewareClasses array of middleware class names to add
     *
     * @throws \InvalidArgumentException if a class does not exist or does not implement Middleware interface
     */
    public function addFromArray(array $middlewareClasses): void
    {
        foreach ($middlewareClasses as $middlewareClass) {
            $this->add($middlewareClass);
        }
    }

    /**
     * Adds a middleware handler to the middleware stack.
     *
     * @param Handler $handler the middleware handler to add to the stack
     */
    public function addHandler(Handler $handler): void
    {
        $this->middlewareStack[] = $handler;
    }

    /**
     * Add multiple middleware handlers to the dispatcher.
     *
     * This method allows for adding multiple middleware handlers at once.
     *
     * @param array<Handler> $handlers an array of middleware handlers to add
     */
    public function addHandlers(array $handlers): void
    {
        foreach ($handlers as $handler) {
            if (!$handler instanceof Handler) {
                throw new \InvalidArgumentException('Handler must be an instance of Handler class.');
            }
            $this->middlewareStack[] = $handler;
        }
    }

    /**
     * Handles the incoming HTTP request by passing it through the middleware stack.
     *
     * This method reverses the middleware stack and wraps each middleware around the next,
     * creating a chain of responsibility. The final handler is called after all middleware
     * have been processed.
     *
     * @param Request  $request      the incoming HTTP request to handle
     * @param callable $finalHandler the final handler to be called after all middleware
     *
     * @return Response the HTTP response generated by the middleware stack or final handler
     */
    public function handle(Request $request, callable $finalHandler): Response
    {
        $stack = array_reverse($this->middlewareStack);
        $next = $finalHandler;
        foreach ($stack as $middleware) {
            $next = function (Request $request) use ($middleware, $next) {
                return $middleware->run($request, $next);
            };
        }

        // Call the final next function which should be the controller or last middleware
        return $next($request);
    }
}
